<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Biometric Analysis System</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üî¨</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    body {
      background-color: #000;
      color: #0ff;
      font-family: 'Share Tech Mono', monospace;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    /* Efecto de Video de Fondo */
    #videoElement {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
      transform: scaleX(-1); /* Efecto espejo */
      filter: contrast(1.2) saturate(0) sepia(100%) hue-rotate(130deg) brightness(0.8); /* Look azulado sci-fi */
    }

    /* Capas de interfaz (debajo del canvas de malla para que los puntos se vean) */
    .overlay-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none; /* Dejar pasar clics */
    }
    /* Wrapper del bot√≥n por encima del canvas de malla para que siga clickeable */
    .action-btn-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 25;
      pointer-events: none;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 2rem;
    }
    .action-btn-wrapper #actionBtn,
    .action-btn-wrapper .btn-results,
    .action-btn-wrapper .results-buttons,
    .action-btn-wrapper .results-buttons button {
      pointer-events: auto;
    }

    /* Animaci√≥n de Escaneo (Barra Verde) */
    .scan-line {
      width: 100%;
      height: 4px;
      background: rgba(0, 255, 255, 0.8);
      box-shadow: 0 0 15px rgba(0, 255, 255, 1);
      position: absolute;
      top: 0;
      animation: scanMove 3s infinite linear;
      display: none; /* Se activa con JS */
    }

    @keyframes scanMove {
      0% { top: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }

    /* Brackets de las esquinas */
    .corner {
      position: absolute;
      width: 40px;
      height: 40px;
      border-color: rgba(255, 255, 0, 0.8);
      border-style: solid;
      transition: all 0.5s ease;
    }
    .tl { top: 20px; left: 20px; border-width: 3px 0 0 3px; }
    .tr { top: 20px; right: 20px; border-width: 3px 3px 0 0; }
    .bl { bottom: 20px; left: 20px; border-width: 0 0 3px 3px; }
    .br { bottom: 20px; right: 20px; border-width: 0 3px 3px 0; }

    /* Wrapper: espejo. Sin filter aqu√≠ para que los puntos cyan se vean. Video se oculta en JS (Chrome lo pintaba encima). */
    .face-mesh-canvas-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 15;
      pointer-events: none;
      transform: scaleX(-1);
    }
    #faceMeshCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Contenedor SVG est√°tico (fallback / oculto cuando hay malla real) */
    .face-mesh-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 280px;
      height: 350px;
      opacity: 0.6;
      transition: transform 0.2s;
      display: none; /* Oculto: usamos canvas con IA */
    }

    .mesh-svg {
      width: 100%;
      height: 100%;
      fill: none;
      stroke: rgba(0, 255, 255, 0.4);
      stroke-width: 1;
    }

    /* Textos parpadeantes */
    .blink { animation: blinker 1s linear infinite; }
    @keyframes blinker { 50% { opacity: 0; } }

    /* Consola de Datos */
    .console-log {
      position: absolute;
      bottom: 80px;
      left: 20px;
      font-size: 12px;
      line-height: 14px;
      color: rgba(0, 255, 255, 0.7);
      text-shadow: 0 0 5px #0ff;
      height: 100px;
      overflow: hidden;
      display: flex;
      flex-direction: column-reverse;
    }

    /* Bot√≥n Principal */
    #actionBtn {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
      pointer-events: auto;
      background: rgba(0, 20, 20, 0.9);
      border: 2px solid #0ff;
      color: #0ff;
      padding: 15px 40px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 18px;
      letter-spacing: 2px;
      text-transform: uppercase;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      transition: all 0.3s;
      cursor: pointer;
    }
    #actionBtn:active {
      background: #0ff;
      color: #000;
    }

    /* Modal de Resultado */
    .result-modal {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s;
    }
    .result-modal.active {
      opacity: 1;
      pointer-events: auto;
    }

    /* Gr√°fico de Barras animado en resultado */
    .bar-container {
      width: 80%;
      height: 20px;
      background: #333;
      margin: 10px 0;
      position: relative;
    }
    .bar-fill {
      height: 100%;
      background: red;
      width: 0%;
      transition: width 2s ease-out;
      box-shadow: 0 0 15px red;
    }
    /* Debug overlay: siempre visible en Chrome/Android para diagnosticar malla */
    #debugOverlay {
      position: fixed;
      top: 8px;
      left: 8px;
      z-index: 99999;
      background: rgba(0,0,0,0.85);
      color: #0f0;
      font-family: monospace;
      font-size: 11px;
      padding: 8px 10px;
      border: 1px solid #0f0;
      pointer-events: none;
      max-width: 280px;
      line-height: 1.35;
    }
    #debugOverlay .warn { color: #fa0; }
    #debugOverlay .err { color: #f44; }

    /* --- Pantallas de resultados S√ç/NO/Empate --- */
    .result-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .result-container {
      text-align: center;
      padding: 60px;
      border-radius: 20px;
      max-width: 600px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    .result-container.positive {
      background: linear-gradient(135deg, #00c853 0%, #64dd17 100%);
      color: white;
    }
    .result-container.negative {
      background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%);
      color: white;
    }
    .result-container.neutral {
      background: linear-gradient(135deg, #ffa726 0%, #ffb74d 100%);
      color: white;
    }
    .result-container h1 {
      font-size: clamp(1.8em, 5vw, 3em);
      margin-bottom: 30px;
      font-weight: bold;
    }
    .percentage-display {
      margin: 40px 0;
    }
    .big-number {
      font-size: clamp(4em, 12vw, 8em);
      font-weight: bold;
      line-height: 1;
    }
    .label {
      font-size: clamp(1.1em, 3vw, 1.5em);
      margin-top: 10px;
      opacity: 0.9;
    }
    .stats-breakdown {
      display: flex;
      justify-content: space-around;
      margin-top: 40px;
      gap: 20px;
    }
    .stat-item {
      font-size: clamp(1.2em, 3vw, 1.8em);
    }
    .stat-item .icon {
      display: block;
      font-size: 2em;
      margin-bottom: 10px;
    }
    .btn-results {
      margin-top: 30px;
      padding: 12px 28px;
      background: rgba(255,255,255,0.25);
      border: 2px solid rgba(255,255,255,0.8);
      color: white;
      font-family: 'Share Tech Mono', monospace;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s;
    }
    .btn-results:hover {
      background: rgba(255,255,255,0.4);
    }
    /* Indicador en vivo S√ç/NO (mejorado) */
    #live-response {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2em;
      font-weight: bold;
      padding: 15px 40px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      border: 3px solid;
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
      z-index: 20;
      transition: all 0.3s;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    /* Slide Mode: resultados para proyecci√≥n */
    .slide-mode {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .slide-mode .slide-container {
      width: 90%;
      max-width: 1200px;
      padding: 60px;
    }
    .slide-mode .slide-header {
      text-align: center;
      margin-bottom: 80px;
    }
    .slide-mode .slide-header h1 {
      font-size: 4em;
      color: #00ffff;
      font-weight: bold;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      margin: 0;
    }
    .slide-mode .vote-bars {
      display: flex;
      flex-direction: column;
      gap: 60px;
    }
    .slide-mode .slide-bar-container {
      display: flex;
      align-items: center;
      gap: 30px;
    }
    .slide-mode .bar-label {
      font-size: 3em;
      font-weight: bold;
      width: 150px;
      text-align: right;
    }
    .slide-mode .bar-wrapper {
      flex: 1;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      height: 80px;
      overflow: hidden;
      border: 2px solid rgba(0, 255, 255, 0.3);
    }
    .slide-mode .bar {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 20px;
      transition: width 1s ease-out;
      border-radius: 15px;
    }
    .slide-mode .bar-yes {
      background: linear-gradient(90deg, #00ff00 0%, #00cc00 100%);
      color: white;
    }
    .slide-mode .bar-no {
      background: linear-gradient(90deg, #ff0000 0%, #cc0000 100%);
      color: white;
    }
    .slide-mode .bar-percentage {
      font-size: 2em;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    .slide-mode .bar-count {
      font-size: 1.8em;
      color: #ffffff;
      width: 200px;
    }
    .slide-mode .slide-footer {
      text-align: center;
      margin-top: 80px;
      font-size: 2em;
      color: #00ffff;
    }
    .slide-mode .btn-close-slide {
      position: absolute;
      top: 30px;
      left: 30px;
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid #00ffff;
      color: #00ffff;
      padding: 15px 30px;
      font-size: 1.2em;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .slide-mode .btn-close-slide:hover {
      background: rgba(0, 255, 255, 0.4);
      transform: translateX(-5px);
    }

    /* Botones de resultados (Ver Resultados / Modo Presentaci√≥n) */
    .results-buttons {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 25;
    }
    .btn-result {
      background: linear-gradient(135deg, #00ffff 0%, #0099cc 100%);
      border: none;
      color: white;
      padding: 15px 30px;
      font-size: 1.1em;
      font-weight: bold;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 255, 255, 0.4);
      transition: all 0.3s;
    }
    .btn-result:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 255, 255, 0.6);
    }
    .btn-slide {
      background: linear-gradient(135deg, #ff00ff 0%, #cc0099 100%);
      box-shadow: 0 4px 15px rgba(255, 0, 255, 0.4);
    }
    .btn-slide:hover {
      box-shadow: 0 6px 20px rgba(255, 0, 255, 0.6);
    }
  </style>
</head>
<body>
  <div class="camera-container">
    <div id="debugOverlay" aria-live="polite">DEBUG: iniciando‚Ä¶</div>
    <div id="debug-coords" style="
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.9);
      color: lime;
      padding: 15px;
      font-family: monospace;
      font-size: 14px;
      z-index: 100;
      border: 2px solid lime;
    "></div>
    <video id="videoElement" autoplay playsinline muted></video>
    <div class="face-mesh-canvas-wrapper" aria-hidden="true">
      <canvas id="faceMeshCanvas"></canvas>
    </div>
    <div class="overlay-layer">
    <div id="scanLine" class="scan-line"></div>
    <div class="corner tl"></div>
    <div class="corner tr"></div>
    <div class="corner bl"></div>
    <div class="corner br"></div>

    <div id="faceMesh" class="face-mesh-container">
      <svg class="mesh-svg" viewBox="0 0 280 350" xmlns="http://www.w3.org/2000/svg">
        <ellipse cx="140" cy="120" rx="70" ry="85" />
        <circle cx="110" cy="100" r="8" />
        <circle cx="170" cy="100" r="8" />
        <path d="M 100 160 Q 140 200 180 160" />
      </svg>
    </div>

    <div id="live-response" aria-live="polite"></div>

    <!-- Contador en vivo visible para la audiencia -->
    <div id="live-vote-counter" style="
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 20px 40px;
      border-radius: 15px;
      border: 2px solid #00ffff;
      z-index: 20;
      display: flex;
      gap: 40px;
      font-family: 'Arial', sans-serif;
      pointer-events: none;
    ">
      <div class="vote-item" style="text-align: center;">
        <div style="font-size: 48px; font-weight: bold; color: #00ff00;">
          <span id="yes-count">0</span>
        </div>
        <div style="font-size: 18px; color: #00ff00; margin-top: 5px;">
          üëç S√ç
        </div>
      </div>
      <div style="width: 2px; background: #00ffff; opacity: 0.3;"></div>
      <div class="vote-item" style="text-align: center;">
        <div style="font-size: 48px; font-weight: bold; color: #ff0000;">
          <span id="no-count">0</span>
        </div>
        <div style="font-size: 18px; color: #ff0000; margin-top: 5px;">
          üëé NO
        </div>
      </div>
    </div>

    <div style="position:absolute; top:20px; left:20px;">
      <span>CAM_01: ACTIVE</span><br>
      <span>RES: 1080p_HDR</span>
    </div>
    <div style="position:absolute; top:20px; right:80px;" class="blink">‚óè REC</div>

    <div id="consoleLog" class="console-log">
      <div>> SYSTEM READY</div>
      <div>> WAITING FOR INPUT...</div>
    </div>

    <div style="position:absolute; bottom:80px; right:20px; font-size:11px;">
      <div>PITCH: <span id="valPitch">120</span> Hz</div>
      <div>STRESS: <span id="valStress">LOW</span></div>
      <div>CONF: <span id="valConf">--</span> %</div>
    </div>

    <div class="action-btn-wrapper">
      <button id="actionBtn" onclick="startAnalysis()">INICIAR ESCANEO</button>
      <div class="results-buttons" id="resultsButtons" style="display: none;">
        <button type="button" onclick="showResults()" class="btn-result">üìä Ver Resultados Completos</button>
        <button type="button" onclick="showSlideMode()" class="btn-result btn-slide">üéØ Modo Presentaci√≥n</button>
      </div>
    </div>
  </div>
  </div>

  <!-- Pantallas de resultados S√ç/NO/Empate -->
  <div id="result-yes" class="result-screen">
    <div class="result-container positive">
      <h1>‚úÖ La Audiencia Dice S√ç</h1>
      <div class="percentage-display">
        <div class="big-number">78%</div>
        <div class="label">Respuestas Positivas</div>
      </div>
      <div class="stats-breakdown">
        <div class="stat-item yes">
          <span class="icon">üëç</span>
          <span class="count">156 S√ç</span>
        </div>
        <div class="stat-item no">
          <span class="icon">üëé</span>
          <span class="count">44 NO</span>
        </div>
      </div>
      <button class="btn-results" onclick="hideResultScreens()">Cerrar</button>
    </div>
  </div>
  <div id="result-no" class="result-screen">
    <div class="result-container negative">
      <h1>‚ùå La Audiencia Dice NO</h1>
      <div class="percentage-display">
        <div class="big-number">65%</div>
        <div class="label">Respuestas Negativas</div>
      </div>
      <div class="stats-breakdown">
        <div class="stat-item yes">
          <span class="icon">üëç</span>
          <span class="count">70 S√ç</span>
        </div>
        <div class="stat-item no">
          <span class="icon">üëé</span>
          <span class="count">130 NO</span>
        </div>
      </div>
      <button class="btn-results" onclick="hideResultScreens()">Cerrar</button>
    </div>
  </div>
  <div id="result-tie" class="result-screen">
    <div class="result-container neutral">
      <h1>‚öñÔ∏è Empate T√©cnico</h1>
      <div class="percentage-display">
        <div class="big-number">50/50</div>
        <div class="label">Opiniones Divididas</div>
      </div>
      <div class="stats-breakdown">
        <div class="stat-item yes">
          <span class="icon">üëç</span>
          <span class="count">100 S√ç</span>
        </div>
        <div class="stat-item no">
          <span class="icon">üëé</span>
          <span class="count">100 NO</span>
        </div>
      </div>
      <button class="btn-results" onclick="hideResultScreens()">Cerrar</button>
    </div>
  </div>

  <!-- Slide Mode: resultados para proyecci√≥n (sin c√°mara) -->
  <div id="result-slide-mode" class="slide-mode" style="display: none;">
    <div class="slide-container">
      <div class="slide-header">
        <h1>Resultados de Votaci√≥n</h1>
      </div>
      <div class="vote-bars">
        <div class="slide-bar-container">
          <div class="bar-label">S√ç</div>
          <div class="bar-wrapper">
            <div id="bar-yes" class="bar bar-yes" style="width: 0%;">
              <span class="bar-percentage">0%</span>
            </div>
          </div>
          <div class="bar-count" id="bar-yes-count">0 votos</div>
        </div>
        <div class="slide-bar-container">
          <div class="bar-label">NO</div>
          <div class="bar-wrapper">
            <div id="bar-no" class="bar bar-no" style="width: 0%;">
              <span class="bar-percentage">0%</span>
            </div>
          </div>
          <div class="bar-count" id="bar-no-count">0 votos</div>
        </div>
      </div>
      <div class="slide-footer">
        <p>Total de participantes: <span id="total-votes">0</span></p>
      </div>
      <button type="button" onclick="closeSlideMode()" class="btn-close-slide">‚Üê Volver a captura</button>
    </div>
  </div>

  <div id="resultModal" class="result-modal">
    <h2>ALERTA</h2>
    <p>AN√ÅLISIS COMPLETADO</p>
    <div class="bar-container"><div class="bar-fill" id="barVocal" style="width:0%"></div></div>
    <span>CONVICCI√ìN VOCAL 32%</span>
    <div class="bar-container"><div class="bar-fill" id="barFacial" style="width:0%"></div></div>
    <span>COHERENCIA FACIAL 41%</span>
    <p><strong>Diagn√≥stico IA</strong></p>
    <p>ALTA INSEGURIDAD DETECTADA</p>
    <button id="resetBtn" onclick="resetDemo()" style="margin-top:20px; padding:10px 25px; background:#0ff; color:#000; border:none; cursor:pointer; font-family: 'Share Tech Mono', monospace;">REINICIAR DEMO</button>
  </div>

  <!-- TEST 5: bot√≥n temporal captura canvas -->
  <button type="button" onclick="captureCanvas()" style="position:fixed; top:10px; right:10px; z-index:9999; padding:10px 16px; background:#333; color:lime; border:2px solid lime; cursor:pointer; font-family:monospace;">Capturar Canvas</button>

  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <script>
    // --- 1. CONFIGURACI√ìN DE C√ÅMARA ---
    const video = document.getElementById('videoElement');
    const faceMeshCanvas = document.getElementById('faceMeshCanvas');
    // Modelos desde el mismo origen (evita CORS en Vercel)
    const MODEL_URL = './weights';

    // === TEST 3: Verificar cu√°ntos canvas hay y sus estilos ===
    window.addEventListener('load', function() {
      var allCanvas = document.querySelectorAll('canvas');
      console.log('üìä Total de canvas en la p√°gina:', allCanvas.length);
      allCanvas.forEach(function(c, i) {
        console.log('Canvas ' + i + ':', {
          id: c.id,
          width: c.width,
          height: c.height,
          zIndex: window.getComputedStyle(c).zIndex,
          visibility: window.getComputedStyle(c).visibility,
          display: window.getComputedStyle(c).display
        });
      });
    });

    // === TEST 5: Capturar frame del canvas ===
    function captureCanvas() {
      var canvas = document.getElementById('faceMeshCanvas');
      if (!canvas) { console.warn('Canvas no encontrado'); return; }
      var dataURL = canvas.toDataURL('image/png');
      var win = window.open();
      if (win) {
        win.document.write('<img src="' + dataURL + '"/>');
        console.log('üì∏ Canvas capturado. Mira la nueva ventana.');
      } else {
        console.log('üì∏ Data URL (pega en nueva pesta√±a):', dataURL.substring(0, 80) + '...');
      }
    }

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
        video.srcObject = stream;
        // === DEBUG 4: eventos de video para diagnosticar pantalla negra ===
        video.addEventListener('loadedmetadata', function() {
          var canvas = document.getElementById('faceMeshCanvas');
          if (canvas && video.videoWidth > 0 && video.videoHeight > 0) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            console.log('‚úÖ Canvas redimensionado a:', canvas.width, 'x', canvas.height);
          }
          console.log('‚úÖ Video ready:', video.videoWidth, 'x', video.videoHeight);
        });
        video.addEventListener('pause', function() {
          console.warn('‚ö†Ô∏è Video pausado!');
          video.play();
        });
        video.addEventListener('suspend', function() {
          console.warn('‚ö†Ô∏è Video suspendido!');
        });
        video.addEventListener('stalled', function() {
          console.warn('‚ö†Ô∏è Video stalled!');
        });
        // FIX 3: si el video/c√°mara cambia de resoluci√≥n (ej. rotar m√≥vil), mantener canvas sincronizado
        window.addEventListener('resize', function() {
          var canvas = document.getElementById('faceMeshCanvas');
          if (canvas && video.videoWidth > 0 && video.videoHeight > 0) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            console.log('üìê Canvas redimensionado (resize):', canvas.width, 'x', canvas.height);
          }
        });
        // === FIN DEBUG 4 (listeners) ===
      } catch (err) {
        console.error("Error acceso c√°mara:", err);
        document.getElementById('consoleLog').innerHTML += ` > ERROR: C√ÅMARA NO DETECTADA `;
        video.style.backgroundColor = "#111";
      }
    }

    // --- MALLA FACIAL EN TIEMPO REAL (face-api.js) ---
    let faceMeshReady = false;
    let previousLandmarksPx = null;
    let responseCounts = { yes: 0, no: 0, neutral: 0 };
    let responseAccumulateFrames = 0;
    const RESPONSE_ACCUMULATE_EVERY = 45; // ~1 voto por segundo (m√°s lento que 10)

    function logToConsole(msg, isError) {
      const el = document.getElementById('consoleLog');
      if (!el) return;
      const div = document.createElement('div');
      div.innerText = '> ' + msg;
      if (isError) div.style.color = '#ff3333';
      el.prepend(div);
    }

    async function initFaceMesh() {
      if (typeof faceapi === 'undefined') {
        logToConsole('FACE MESH: script no carg√≥ (bloqueador o red)', true);
        console.error('face-api.js no est√° definido. ¬øBloqueador de anuncios o fallo de red?');
        return;
      }
      // En Chrome/Android el canvas con frame de getUserMedia a veces no va bien con WebGL.
      // Forzar CPU en esos navegadores suele hacer que la detecci√≥n funcione (como en Safari/iPhone).
      const isChromeOrAndroid = /Chrome|Android/i.test(navigator.userAgent) && !/Safari|iPhone|iPad/.test(navigator.userAgent);
      const tfRef = typeof tf !== 'undefined' ? tf : (typeof faceapi !== 'undefined' && faceapi.tf ? faceapi.tf : null);
      if (isChromeOrAndroid && tfRef) {
        try {
          await tfRef.setBackend('cpu');
          await tfRef.ready();
          console.log('üîß Backend TensorFlow: CPU (Chrome/Android)');
        } catch (e) {
          console.warn('Backend CPU no disponible:', e);
        }
      }
      logToConsole('FACE MESH: cargando modelos...', false);
      try {
        await Promise.all([
          faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
          faceapi.loadFaceLandmarkModel(MODEL_URL)
        ]);
        faceMeshReady = true;
        logToConsole('FACE MESH: listo', false);
      } catch (err) {
        logToConsole('FACE MESH: error (abre F12 ‚Üí Console)', true);
        console.error('Face mesh error:', err);
      }
    }

    // Convierte landmarks de una detecci√≥n a coordenadas en p√≠xeles (para an√°lisis S√ç/NO)
    function getLandmarksInPixels(detection, w, h) {
      const positions = detection.landmarks.positions;
      const box = detection.detection?.box;
      const boxX = (box && typeof box.x === 'number') ? box.x : 0;
      const boxY = (box && typeof box.y === 'number') ? box.y : 0;
      const boxW = (box && typeof box.width === 'number') ? box.width : w;
      const boxH = (box && typeof box.height === 'number') ? box.height : h;
      const first = positions[0];
      const normalized = first && first.x <= 1 && first.y <= 1;
      const likelyBoxRelative = first && box && first.x >= 0 && first.x <= boxW && first.y >= 0 && first.y <= boxH;
      const out = [];
      for (let i = 0; i < positions.length; i++) {
        let x = positions[i].x;
        let y = positions[i].y;
        if (normalized) {
          x *= w;
          y *= h;
        } else if (likelyBoxRelative) {
          x += boxX;
          y += boxY;
        }
        out.push({ x, y });
      }
      return out;
    }

    function analyzeFacialResponse(landmarks, previousLandmarks) {
      let yesScore = 0;
      let noScore = 0;
      if (!landmarks || landmarks.length < 58) return 'NEUTRAL';

      const mouthLeft = landmarks[48];
      const mouthRight = landmarks[54];
      const noseTip = landmarks[30];
      if (mouthLeft && mouthRight && noseTip && mouthLeft.y < noseTip.y && mouthRight.y < noseTip.y) {
        yesScore += 2;
      }

      const leftEyebrow = landmarks[19];
      const rightEyebrow = landmarks[24];
      const leftEye = landmarks[37];
      if (leftEyebrow && leftEye) {
        const eyebrowDistance = leftEye.y - leftEyebrow.y;
        if (eyebrowDistance > 15) yesScore += 1;
      }
      if (rightEyebrow && landmarks[42]) {
        const eyebrowDistanceR = landmarks[42].y - rightEyebrow.y;
        if (eyebrowDistanceR > 15) yesScore += 1;
      }

      if (previousLandmarks && previousLandmarks.length >= 31) {
        const currentNose = landmarks[30];
        const prevNose = previousLandmarks[30];
        const verticalMove = Math.abs(currentNose.y - prevNose.y);
        if (verticalMove > 5) yesScore += 1;
        const horizontalMove = Math.abs(currentNose.x - prevNose.x);
        if (horizontalMove > 6) noScore += 2; // peso extra para cabeceo NO
      }

      const mouthTop = landmarks[51];
      const mouthBottom = landmarks[57];
      if (mouthTop && mouthBottom) {
        const mouthHeight = mouthBottom.y - mouthTop.y;
        if (mouthHeight < 5) noScore += 1;
      }

      // Exigir se√±al clara para S√ç (evitar que todo sea S√ç con cara neutra)
      if (yesScore > noScore && yesScore >= 2) return 'YES';
      if (noScore > yesScore) return 'NO';
      // Mezcla en demo: ~20% de los que ser√≠an S√ç pasan a NO para variedad
      if (yesScore > noScore && yesScore >= 1 && Math.random() < 0.2) return 'NO';
      if (yesScore > noScore) return 'YES';
      return 'NEUTRAL';
    }

    // Throttle para logs temporales (no saturar consola)
    let drawFaceMeshLogTick = 0;
    const DRAW_MESH_LOG_EVERY = 60;

    function drawFaceMeshCyan(ctx, results, width, height) {
      if (!results || results.length === 0) return;
      const w = width || ctx.canvas.width;
      const h = height || ctx.canvas.height;
      const radiusCyan = 5;
      const fillStyleCyan = 'rgba(0, 255, 255, 0.95)';
      results.forEach((detection) => {
        const positions = detection.landmarks.positions;
        const box = detection.detection?.box;
        const boxX = (box && typeof box.x === 'number') ? box.x : 0;
        const boxY = (box && typeof box.y === 'number') ? box.y : 0;
        const boxW = (box && typeof box.width === 'number') ? box.width : w;
        const boxH = (box && typeof box.height === 'number') ? box.height : h;
        const first = positions[0];
        const normalized = first && first.x <= 1 && first.y <= 1;
        const likelyBoxRelative = first && box && first.x >= 0 && first.x <= boxW && first.y >= 0 && first.y <= boxH;
        for (let i = 0; i < positions.length; i++) {
          let x = positions[i].x;
          let y = positions[i].y;
          if (normalized) {
            x *= w;
            y *= h;
          } else if (likelyBoxRelative) {
            x += boxX;
            y += boxY;
          }
          ctx.shadowColor = '#0ff';
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.arc(x, y, radiusCyan, 0, Math.PI * 2);
          ctx.fillStyle = fillStyleCyan;
          ctx.fill();
          ctx.strokeStyle = '#0ff';
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
      });
    }

    // Funci√≥n helper para esperar video listo (debug)
    async function waitForVideoReady(videoEl) {
      return new Promise((resolve) => {
        const check = () => {
          if (videoEl.readyState >= 2 && videoEl.videoWidth > 0) {
            console.log('‚úÖ Video listo:', videoEl.videoWidth, 'x', videoEl.videoHeight);
            resolve();
          } else {
            console.log('‚è≥ Esperando video...', videoEl.readyState);
            setTimeout(check, 100);
          }
        };
        check();
      });
    }

    // Opciones del detector relajadas para mejor detecci√≥n
    const faceDetectorOptions = new faceapi.TinyFaceDetectorOptions({
      inputSize: 416,
      scoreThreshold: 0.1
    });

    // Canvas auxiliar: SOLO para detecci√≥n (face-api lee de aqu√≠). Video + malla se dibujan en el canvas VISIBLE (arregla Chrome/Android).
    let offscreenCanvas = null;
    let debugThrottle = 0;
    let dimensionLogThrottle = 0;
    const debugEl = () => document.getElementById('debugOverlay');

    /*
     * === TEST 1: ORDEN COMPLETO DEL LOOP DE DETECCI√ìN ===
     * 1. NO hay clearRect expl√≠cito.
     * 2. faceMeshCanvas.width = w; faceMeshCanvas.height = h;  (al inicio) -> ESO BORRA el canvas.
     * 3. offscreenCanvas: offCtx.drawImage(video, 0, 0, w, h)  (solo en canvas auxiliar, no el visible).
     * 4. await faceapi.detectAllFaces(offscreenCanvas...)  (async).
     * 5. Si results.length > 0:
     *    a) ctx.drawImage(video, 0, 0, w, h)  -> pinta video en canvas VISIBLE (faceMeshCanvas).
     *    b) ctx.fillRect(centro)  -> cuadrado rojo centro.
     *    c) drawFaceMeshCyan(ctx, results, w, h)  -> puntos + DEBUG 3 c√≠rculos + TEST 2 cuadrado rojo.
     *    d) DEBUG 1: cuadrados magenta/amarillo/cyan + texto "CANVAS OK".
     *    e) DEBUG 2: actualiza #debug-coords.
     *    f) TEST 4: c√≠rculo lime centro en canvas visible.
     * 6. Si results.length === 0: ctx.drawImage(video, 0, 0, w, h) solo.
     * 7. requestAnimationFrame(detectFaceMesh).
     * ctx es SIEMPRE faceMeshCanvas.getContext('2d') -> el √∫nico canvas visible para la malla.
     */
    async function detectFaceMesh() {
      if (!faceMeshReady || video.readyState < 2) {
        requestAnimationFrame(detectFaceMesh);
        return;
      }
      const ctx = faceMeshCanvas.getContext('2d');
      if (!ctx) {
        requestAnimationFrame(detectFaceMesh);
        return;
      }
      const w = video.videoWidth;
      const h = video.videoHeight;
      // No dibujar si el video a√∫n no tiene dimensiones v√°lidas (evita canvas 300x150 por defecto)
      if (!w || !h || w < 100 || h < 100) {
        requestAnimationFrame(detectFaceMesh);
        return;
      }
      // Chrome pinta <video> en capa aparte y tapa el canvas: ocultar video y mostrar solo canvas (frame + puntos)
      if (video.style.visibility !== 'hidden') video.style.visibility = 'hidden';
      faceMeshCanvas.width = w;
      faceMeshCanvas.height = h;

      // Detecci√≥n desde un canvas con el frame actual (en algunos navegadores detectAllFaces(video) devuelve 0 caras)
      if (!offscreenCanvas || offscreenCanvas.width !== w || offscreenCanvas.height !== h) {
        offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = w;
        offscreenCanvas.height = h;
      }
      var offCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
      offCtx.drawImage(video, 0, 0, w, h);
      var results = await faceapi.detectAllFaces(offscreenCanvas, faceDetectorOptions).withFaceLandmarks();

      // Verificaci√≥n dimensiones (log temporal cada ~60 frames)
      if (dimensionLogThrottle++ % 60 === 0) {
        console.log('üîç Dimensiones:', {
          videoW: video.videoWidth,
          videoH: video.videoHeight,
          canvasW: faceMeshCanvas.width,
          canvasH: faceMeshCanvas.height,
          match: video.videoWidth === faceMeshCanvas.width && video.videoHeight === faceMeshCanvas.height ? '‚úÖ' : '‚ùå'
        });
      }

      // Pintar siempre el frame del video en el canvas visible
      ctx.drawImage(video, 0, 0, w, h);
      // PRUEBA: si esto NO se ve en Chrome, el canvas no se muestra. Si S√ç se ve, el fallo est√° en drawFaceMeshCyan.
      ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
      ctx.fillRect(w / 2 - 60, h / 2 - 40, 120, 80);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 32px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('CANVAS OK', w / 2, h / 2 + 6);
      if (results.length > 0) {
        drawFaceMeshCyan(ctx, results, w, h);

        var debugDiv = document.getElementById('debug-coords');
        if (debugDiv) {
          var fp = results[0].landmarks.positions[0];
          var lp = results[0].landmarks.positions[67];
          debugDiv.innerHTML = '<strong>DEVICE:</strong> ' + (/iPhone|iPad/.test(navigator.userAgent) ? 'iPhone' : 'Chrome') + '<br>' +
            '<strong>Canvas:</strong> ' + faceMeshCanvas.width + 'x' + faceMeshCanvas.height + '<br>' +
            '<strong>Video:</strong> ' + video.videoWidth + 'x' + video.videoHeight + '<br>' +
            '<strong>Punto 0:</strong> (' + fp.x.toFixed(1) + ', ' + fp.y.toFixed(1) + ')<br>' +
            '<strong>Punto 67:</strong> (' + lp.x.toFixed(1) + ', ' + lp.y.toFixed(1) + ')<br>' +
            '<strong>Total puntos:</strong> ' + results[0].landmarks.positions.length;
        }

        const d = results[0];
        const landmarksPx = getLandmarksInPixels(d, w, h);
        const response = analyzeFacialResponse(landmarksPx, previousLandmarksPx);
        responseAccumulateFrames++;
        if (responseAccumulateFrames >= RESPONSE_ACCUMULATE_EVERY) {
          responseAccumulateFrames = 0;
          if (response === 'YES') responseCounts.yes++;
          if (response === 'NO') responseCounts.no++;
          if (response === 'NEUTRAL') responseCounts.neutral++;
          const yesCountEl = document.getElementById('yes-count');
          const noCountEl = document.getElementById('no-count');
          if (yesCountEl) yesCountEl.textContent = responseCounts.yes;
          if (noCountEl) noCountEl.textContent = responseCounts.no;
        }
        previousLandmarksPx = landmarksPx;

        const liveEl = document.getElementById('live-response');
        if (liveEl) {
          if (response === 'YES') {
            liveEl.textContent = 'üëç Detectando S√ç';
            liveEl.style.color = '#00ff00';
            liveEl.style.borderColor = '#00ff00';
          } else if (response === 'NO') {
            liveEl.textContent = 'üëé Detectando NO';
            liveEl.style.color = '#ff0000';
            liveEl.style.borderColor = '#ff0000';
          } else {
            liveEl.textContent = 'üòê Neutral';
            liveEl.style.color = '#ffaa00';
            liveEl.style.borderColor = '#ffaa00';
          }
        }
        const btnResults = document.getElementById('resultsButtons');
        if (btnResults) btnResults.style.display = 'flex';

        if (debugThrottle++ % 30 === 0 && debugEl()) {
          const d = results[0];
          const pos = d.landmarks.positions;
          const first = pos[0];
          const box = d.detection?.box;
          const boxStr = box ? `box: ${Math.round(box.x)},${Math.round(box.y)} ${Math.round(box.width)}x${Math.round(box.height)}` : 'box: n/a';
          debugEl().innerHTML =
            `CANVAS: ${w}√ó${h}<br>` +
            `CARAS: ${results.length} | PTS: ${pos.length}<br>` +
            `first: (${first ? Math.round(first.x) : '?'}, ${first ? Math.round(first.y) : '?'})<br>` +
            boxStr + '<br>' +
            (first && first.x <= 1 ? '<span class="warn">coords normalizadas?</span>' : '') +
            (first && box && first.x >= 0 && first.x <= box.width && first.y >= 0 && first.y <= box.height ? '<br><span class="warn">usando offset box</span>' : '');
        }
      } else {
        previousLandmarksPx = null;
        const liveEl = document.getElementById('live-response');
        if (liveEl) {
          liveEl.textContent = '';
        }
        var debugDivEmpty = document.getElementById('debug-coords');
        if (debugDivEmpty) debugDivEmpty.innerHTML = '';
        if (debugThrottle++ % 30 === 0 && debugEl()) {
          debugEl().innerHTML = `CANVAS: ${w}√ó${h}<br>CARAS: 0<br><span class="err">Sin cara detectada</span>`;
        }
      }

      requestAnimationFrame(detectFaceMesh);
    }

    (async function init() {
      await startCamera();
      let detectionStarted = false;
      const startDetection = async () => {
        if (detectionStarted) return;
        detectionStarted = true;
        await initFaceMesh();
        await waitForVideoReady(video);
        // FIX 1: sincronizar tama√±o del canvas con el video antes de iniciar el loop
        var canvas = document.getElementById('faceMeshCanvas');
        if (canvas && video.videoWidth > 0 && video.videoHeight > 0) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          console.log('‚úÖ Canvas redimensionado a:', canvas.width, 'x', canvas.height);
        }
        // NO ocultar el video aqu√≠: se oculta solo cuando el loop haya dibujado el primer frame (evita pantalla negra)
        console.log('üé¨ Iniciando loop de detecci√≥n...');
        // === DEBUG 4: mantener pantalla activa en m√≥viles ===
        if ('wakeLock' in navigator) {
          navigator.wakeLock.request('screen').catch(function(err) {
            console.log('WakeLock no disponible:', err);
          });
        }
        detectFaceMesh();
      };
      video.addEventListener('loadedmetadata', startDetection);
      if (video.readyState >= 2) {
        await startDetection();
      }
    })();

    // --- 2. L√ìGICA DE SIMULACI√ìN ---
    setInterval(() => {
      document.getElementById('valPitch').innerText = Math.floor(Math.random() * (160 - 100) + 100);
      const stressLevels = ["LOW", "MED", "HIGH"];
      document.getElementById('valStress').innerText = stressLevels[Math.floor(Math.random() * stressLevels.length)];
    }, 500);

    const fakeLogs = [
      "INITIALIZING BIO-SENSORS...",
      "AUDIO INPUT: DETECTED",
      "CALIBRATING FACE MESH...",
      "LOCKING TARGET...",
      "MICRO-TREMOR DETECTED (t=0.4s)",
      "PUPIL DILATION: IRREGULAR",
      "VOICE FREQUENCY: UNSTABLE",
      "CONFIDENCE INTERVAL: DROPPING",
      "CORRELATING DATA WITH CLOUD...",
      "GENERATING FINAL REPORT..."
    ];

    function startAnalysis() {
      const btn = document.getElementById('actionBtn');
      const scanLine = document.getElementById('scanLine');
      const consoleDiv = document.getElementById('consoleLog');
      const faceMesh = document.getElementById('faceMesh');

      btn.style.display = 'none';
      scanLine.style.display = 'block';

      faceMesh.style.transform = "translate(-50%, -50%) scale(1.1)";
      setInterval(() => {
        faceMesh.style.transform = faceMesh.style.transform === "translate(-50%, -50%) scale(1.1)"
          ? "translate(-50%, -50%) scale(1.0)"
          : "translate(-50%, -50%) scale(1.1)";
      }, 800);

      let delay = 0;
      fakeLogs.forEach((log, index) => {
        delay += (index < 3) ? 500 : 250;
        setTimeout(() => {
          const entry = document.createElement('div');
          entry.innerText = `> ${log}`;
          if(log.includes("UNSTABLE") || log.includes("DROPPING")) entry.style.color = "#ff3333";
          consoleDiv.prepend(entry);
        }, delay);
      });

      setTimeout(() => {
        showResult();
      }, delay + 1000);
    }

    function showResult() {
      const modal = document.getElementById('resultModal');
      const barVocal = document.getElementById('barVocal');
      const barFacial = document.getElementById('barFacial');
      barVocal.style.width = '0%';
      barFacial.style.width = '0%';
      modal.classList.add('active');
      requestAnimationFrame(() => {
        barVocal.style.width = '32%';
        barFacial.style.width = '41%';
      });
    }

    function resetDemo() {
      document.getElementById('resultModal').classList.remove('active');
      document.getElementById('barVocal').style.width = '0%';
      document.getElementById('barFacial').style.width = '0%';
      document.getElementById('actionBtn').style.display = 'block';
      document.getElementById('scanLine').style.display = 'none';
      document.getElementById('consoleLog').innerHTML = '<div>> SYSTEM READY</div><div>> WAITING FOR INPUT...</div>';
      document.getElementById('faceMesh').style.transform = 'translate(-50%, -50%)';
    }

    function showResults() {
      const total = responseCounts.yes + responseCounts.no;
      const cameraContainer = document.querySelector('.camera-container');
      if (!cameraContainer) return;
      document.getElementById('result-yes').style.display = 'none';
      document.getElementById('result-no').style.display = 'none';
      document.getElementById('result-tie').style.display = 'none';

      if (total === 0) {
        document.getElementById('live-response').textContent = 'Sin datos a√∫n';
        return;
      }
      cameraContainer.style.display = 'none';
      const yesPercent = (responseCounts.yes / total) * 100;
      const noPercent = (responseCounts.no / total) * 100;

      if (Math.abs(yesPercent - noPercent) < 5) {
        document.getElementById('result-tie').style.display = 'flex';
        document.querySelector('#result-tie .stat-item.yes .count').textContent = responseCounts.yes + ' S√ç';
        document.querySelector('#result-tie .stat-item.no .count').textContent = responseCounts.no + ' NO';
      } else if (yesPercent > noPercent) {
        document.getElementById('result-yes').style.display = 'flex';
        document.querySelector('#result-yes .big-number').textContent = Math.round(yesPercent) + '%';
        document.querySelector('#result-yes .stat-item.yes .count').textContent = responseCounts.yes + ' S√ç';
        document.querySelector('#result-yes .stat-item.no .count').textContent = responseCounts.no + ' NO';
      } else {
        document.getElementById('result-no').style.display = 'flex';
        document.querySelector('#result-no .big-number').textContent = Math.round(noPercent) + '%';
        document.querySelector('#result-no .stat-item.yes .count').textContent = responseCounts.yes + ' S√ç';
        document.querySelector('#result-no .stat-item.no .count').textContent = responseCounts.no + ' NO';
      }
    }

    function hideResultScreens() {
      document.getElementById('result-yes').style.display = 'none';
      document.getElementById('result-no').style.display = 'none';
      document.getElementById('result-tie').style.display = 'none';
      const cameraContainer = document.querySelector('.camera-container');
      if (cameraContainer) cameraContainer.style.display = '';
    }

    function showSlideMode() {
      const total = responseCounts.yes + responseCounts.no;
      const yesPercent = total > 0 ? ((responseCounts.yes / total) * 100) : 0;
      const noPercent = total > 0 ? ((responseCounts.no / total) * 100) : 0;

      document.querySelector('.camera-container').style.display = 'none';
      document.getElementById('result-yes').style.display = 'none';
      document.getElementById('result-no').style.display = 'none';
      document.getElementById('result-tie').style.display = 'none';
      document.getElementById('result-slide-mode').style.display = 'flex';

      setTimeout(function() {
        var barYes = document.getElementById('bar-yes');
        var barNo = document.getElementById('bar-no');
        barYes.style.width = yesPercent + '%';
        barYes.querySelector('.bar-percentage').textContent = Math.round(yesPercent) + '%';
        document.getElementById('bar-yes-count').textContent = responseCounts.yes + ' votos';

        barNo.style.width = noPercent + '%';
        barNo.querySelector('.bar-percentage').textContent = Math.round(noPercent) + '%';
        document.getElementById('bar-no-count').textContent = responseCounts.no + ' votos';

        document.getElementById('total-votes').textContent = total;
      }, 100);
    }

    function closeSlideMode() {
      document.getElementById('result-slide-mode').style.display = 'none';
      document.querySelector('.camera-container').style.display = 'block';
    }
  </script>
</body>
</html>
