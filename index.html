<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Biometric Analysis System</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üî¨</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    body {
      background-color: #000;
      color: #0ff;
      font-family: 'Share Tech Mono', monospace;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    /* Efecto de Video de Fondo */
    #videoElement {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
      transform: scaleX(-1); /* Efecto espejo */
      filter: contrast(1.2) saturate(0) sepia(100%) hue-rotate(130deg) brightness(0.8); /* Look azulado sci-fi */
    }

    /* Capas de interfaz (debajo del canvas de malla para que los puntos se vean) */
    .overlay-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none; /* Dejar pasar clics */
    }
    /* Wrapper del bot√≥n por encima del canvas de malla para que siga clickeable */
    .action-btn-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 25;
      pointer-events: none;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 2rem;
    }
    .action-btn-wrapper #actionBtn,
    .action-btn-wrapper .btn-results {
      pointer-events: auto;
    }
    .action-btn-wrapper #btnVerResultados {
      background: rgba(0, 20, 20, 0.9);
      border: 2px solid #0ff;
      color: #0ff;
      font-family: 'Share Tech Mono', monospace;
      padding: 15px 28px;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
    }
    .action-btn-wrapper #btnVerResultados:hover {
      background: rgba(0, 255, 255, 0.15);
    }

    /* Animaci√≥n de Escaneo (Barra Verde) */
    .scan-line {
      width: 100%;
      height: 4px;
      background: rgba(0, 255, 255, 0.8);
      box-shadow: 0 0 15px rgba(0, 255, 255, 1);
      position: absolute;
      top: 0;
      animation: scanMove 3s infinite linear;
      display: none; /* Se activa con JS */
    }

    @keyframes scanMove {
      0% { top: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }

    /* Brackets de las esquinas */
    .corner {
      position: absolute;
      width: 40px;
      height: 40px;
      border-color: rgba(255, 255, 0, 0.8);
      border-style: solid;
      transition: all 0.5s ease;
    }
    .tl { top: 20px; left: 20px; border-width: 3px 0 0 3px; }
    .tr { top: 20px; right: 20px; border-width: 3px 3px 0 0; }
    .bl { bottom: 20px; left: 20px; border-width: 0 0 3px 3px; }
    .br { bottom: 20px; right: 20px; border-width: 0 3px 3px 0; }

    /* Canvas: muestra video + malla (mismo look que el video para iPhone/Chrome/Android) */
    #faceMeshCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 15;
      pointer-events: none;
      transform: scaleX(-1) translateZ(0);
      backface-visibility: hidden;
      object-fit: cover;
      filter: contrast(1.2) saturate(0) sepia(100%) hue-rotate(130deg) brightness(0.8); /* Igual que #videoElement */
    }

    /* Contenedor SVG est√°tico (fallback / oculto cuando hay malla real) */
    .face-mesh-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 280px;
      height: 350px;
      opacity: 0.6;
      transition: transform 0.2s;
      display: none; /* Oculto: usamos canvas con IA */
    }

    .mesh-svg {
      width: 100%;
      height: 100%;
      fill: none;
      stroke: rgba(0, 255, 255, 0.4);
      stroke-width: 1;
    }

    /* Textos parpadeantes */
    .blink { animation: blinker 1s linear infinite; }
    @keyframes blinker { 50% { opacity: 0; } }

    /* Consola de Datos */
    .console-log {
      position: absolute;
      bottom: 80px;
      left: 20px;
      font-size: 12px;
      line-height: 14px;
      color: rgba(0, 255, 255, 0.7);
      text-shadow: 0 0 5px #0ff;
      height: 100px;
      overflow: hidden;
      display: flex;
      flex-direction: column-reverse;
    }

    /* Bot√≥n Principal */
    #actionBtn {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
      pointer-events: auto;
      background: rgba(0, 20, 20, 0.9);
      border: 2px solid #0ff;
      color: #0ff;
      padding: 15px 40px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 18px;
      letter-spacing: 2px;
      text-transform: uppercase;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      transition: all 0.3s;
      cursor: pointer;
    }
    #actionBtn:active {
      background: #0ff;
      color: #000;
    }

    /* Modal de Resultado */
    .result-modal {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s;
    }
    .result-modal.active {
      opacity: 1;
      pointer-events: auto;
    }

    /* Gr√°fico de Barras animado en resultado */
    .bar-container {
      width: 80%;
      height: 20px;
      background: #333;
      margin: 10px 0;
      position: relative;
    }
    .bar-fill {
      height: 100%;
      background: red;
      width: 0%;
      transition: width 2s ease-out;
      box-shadow: 0 0 15px red;
    }
    /* Debug overlay: siempre visible en Chrome/Android para diagnosticar malla */
    #debugOverlay {
      position: fixed;
      top: 8px;
      left: 8px;
      z-index: 99999;
      background: rgba(0,0,0,0.85);
      color: #0f0;
      font-family: monospace;
      font-size: 11px;
      padding: 8px 10px;
      border: 1px solid #0f0;
      pointer-events: none;
      max-width: 280px;
      line-height: 1.35;
    }
    #debugOverlay .warn { color: #fa0; }
    #debugOverlay .err { color: #f44; }

    /* --- Pantallas de resultados S√ç/NO/Empate --- */
    .result-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .result-container {
      text-align: center;
      padding: 60px;
      border-radius: 20px;
      max-width: 600px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    .result-container.positive {
      background: linear-gradient(135deg, #00c853 0%, #64dd17 100%);
      color: white;
    }
    .result-container.negative {
      background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%);
      color: white;
    }
    .result-container.neutral {
      background: linear-gradient(135deg, #ffa726 0%, #ffb74d 100%);
      color: white;
    }
    .result-container h1 {
      font-size: clamp(1.8em, 5vw, 3em);
      margin-bottom: 30px;
      font-weight: bold;
    }
    .percentage-display {
      margin: 40px 0;
    }
    .big-number {
      font-size: clamp(4em, 12vw, 8em);
      font-weight: bold;
      line-height: 1;
    }
    .label {
      font-size: clamp(1.1em, 3vw, 1.5em);
      margin-top: 10px;
      opacity: 0.9;
    }
    .stats-breakdown {
      display: flex;
      justify-content: space-around;
      margin-top: 40px;
      gap: 20px;
    }
    .stat-item {
      font-size: clamp(1.2em, 3vw, 1.8em);
    }
    .stat-item .icon {
      display: block;
      font-size: 2em;
      margin-bottom: 10px;
    }
    .btn-results {
      margin-top: 30px;
      padding: 12px 28px;
      background: rgba(255,255,255,0.25);
      border: 2px solid rgba(255,255,255,0.8);
      color: white;
      font-family: 'Share Tech Mono', monospace;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s;
    }
    .btn-results:hover {
      background: rgba(255,255,255,0.4);
    }
    /* Indicador en vivo S√ç/NO */
    #live-response {
      position: absolute;
      top: 120px;
      left: 10px;
      font-size: 24px;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 4px black;
      z-index: 20;
      transition: color 0.2s;
    }
  </style>
</head>
<body>
  <div class="camera-container">
    <div id="debugOverlay" aria-live="polite">DEBUG: iniciando‚Ä¶</div>
    <video id="videoElement" autoplay playsinline muted></video>
    <canvas id="faceMeshCanvas" aria-hidden="true"></canvas>
    <div class="overlay-layer">
    <div id="scanLine" class="scan-line"></div>
    <div class="corner tl"></div>
    <div class="corner tr"></div>
    <div class="corner bl"></div>
    <div class="corner br"></div>

    <div id="faceMesh" class="face-mesh-container">
      <svg class="mesh-svg" viewBox="0 0 280 350" xmlns="http://www.w3.org/2000/svg">
        <ellipse cx="140" cy="120" rx="70" ry="85" />
        <circle cx="110" cy="100" r="8" />
        <circle cx="170" cy="100" r="8" />
        <path d="M 100 160 Q 140 200 180 160" />
      </svg>
    </div>

    <div id="live-response" aria-live="polite"></div>
    <div style="position:absolute; top:20px; left:20px;">
      <span>CAM_01: ACTIVE</span><br>
      <span>RES: 1080p_HDR</span>
    </div>
    <div style="position:absolute; top:20px; right:80px;" class="blink">‚óè REC</div>

    <div id="consoleLog" class="console-log">
      <div>> SYSTEM READY</div>
      <div>> WAITING FOR INPUT...</div>
    </div>

    <div style="position:absolute; bottom:80px; right:20px; font-size:11px;">
      <div>PITCH: <span id="valPitch">120</span> Hz</div>
      <div>STRESS: <span id="valStress">LOW</span></div>
      <div>CONF: <span id="valConf">--</span> %</div>
    </div>

    <div class="action-btn-wrapper">
      <button id="actionBtn" onclick="startAnalysis()">INICIAR ESCANEO</button>
      <button id="btnVerResultados" class="btn-results" onclick="showResults()" style="display:none; margin-left:16px;">Ver Resultados</button>
    </div>
  </div>
  </div>

  <!-- Pantallas de resultados S√ç/NO/Empate -->
  <div id="result-yes" class="result-screen">
    <div class="result-container positive">
      <h1>‚úÖ La Audiencia Dice S√ç</h1>
      <div class="percentage-display">
        <div class="big-number">78%</div>
        <div class="label">Respuestas Positivas</div>
      </div>
      <div class="stats-breakdown">
        <div class="stat-item yes">
          <span class="icon">üëç</span>
          <span class="count">156 S√ç</span>
        </div>
        <div class="stat-item no">
          <span class="icon">üëé</span>
          <span class="count">44 NO</span>
        </div>
      </div>
      <button class="btn-results" onclick="hideResultScreens()">Cerrar</button>
    </div>
  </div>
  <div id="result-no" class="result-screen">
    <div class="result-container negative">
      <h1>‚ùå La Audiencia Dice NO</h1>
      <div class="percentage-display">
        <div class="big-number">65%</div>
        <div class="label">Respuestas Negativas</div>
      </div>
      <div class="stats-breakdown">
        <div class="stat-item yes">
          <span class="icon">üëç</span>
          <span class="count">70 S√ç</span>
        </div>
        <div class="stat-item no">
          <span class="icon">üëé</span>
          <span class="count">130 NO</span>
        </div>
      </div>
      <button class="btn-results" onclick="hideResultScreens()">Cerrar</button>
    </div>
  </div>
  <div id="result-tie" class="result-screen">
    <div class="result-container neutral">
      <h1>‚öñÔ∏è Empate T√©cnico</h1>
      <div class="percentage-display">
        <div class="big-number">50/50</div>
        <div class="label">Opiniones Divididas</div>
      </div>
      <div class="stats-breakdown">
        <div class="stat-item yes">
          <span class="icon">üëç</span>
          <span class="count">100 S√ç</span>
        </div>
        <div class="stat-item no">
          <span class="icon">üëé</span>
          <span class="count">100 NO</span>
        </div>
      </div>
      <button class="btn-results" onclick="hideResultScreens()">Cerrar</button>
    </div>
  </div>

  <div id="resultModal" class="result-modal">
    <h2>ALERTA</h2>
    <p>AN√ÅLISIS COMPLETADO</p>
    <div class="bar-container"><div class="bar-fill" id="barVocal" style="width:0%"></div></div>
    <span>CONVICCI√ìN VOCAL 32%</span>
    <div class="bar-container"><div class="bar-fill" id="barFacial" style="width:0%"></div></div>
    <span>COHERENCIA FACIAL 41%</span>
    <p><strong>Diagn√≥stico IA</strong></p>
    <p>ALTA INSEGURIDAD DETECTADA</p>
    <button id="resetBtn" onclick="resetDemo()" style="margin-top:20px; padding:10px 25px; background:#0ff; color:#000; border:none; cursor:pointer; font-family: 'Share Tech Mono', monospace;">REINICIAR DEMO</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <script>
    // --- 1. CONFIGURACI√ìN DE C√ÅMARA ---
    const video = document.getElementById('videoElement');
    const faceMeshCanvas = document.getElementById('faceMeshCanvas');
    // Modelos desde el mismo origen (evita CORS en Vercel)
    const MODEL_URL = './weights';

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
        video.srcObject = stream;
      } catch (err) {
        console.error("Error acceso c√°mara:", err);
        document.getElementById('consoleLog').innerHTML += ` > ERROR: C√ÅMARA NO DETECTADA `;
        video.style.backgroundColor = "#111";
      }
    }

    // --- MALLA FACIAL EN TIEMPO REAL (face-api.js) ---
    let faceMeshReady = false;
    let previousLandmarksPx = null;
    let responseCounts = { yes: 0, no: 0, neutral: 0 };
    let responseAccumulateFrames = 0;
    const RESPONSE_ACCUMULATE_EVERY = 10;

    function logToConsole(msg, isError) {
      const el = document.getElementById('consoleLog');
      if (!el) return;
      const div = document.createElement('div');
      div.innerText = '> ' + msg;
      if (isError) div.style.color = '#ff3333';
      el.prepend(div);
    }

    async function initFaceMesh() {
      if (typeof faceapi === 'undefined') {
        logToConsole('FACE MESH: script no carg√≥ (bloqueador o red)', true);
        console.error('face-api.js no est√° definido. ¬øBloqueador de anuncios o fallo de red?');
        return;
      }
      // En Chrome/Android el canvas con frame de getUserMedia a veces no va bien con WebGL.
      // Forzar CPU en esos navegadores suele hacer que la detecci√≥n funcione (como en Safari/iPhone).
      const isChromeOrAndroid = /Chrome|Android/i.test(navigator.userAgent) && !/Safari|iPhone|iPad/.test(navigator.userAgent);
      const tfRef = typeof tf !== 'undefined' ? tf : (typeof faceapi !== 'undefined' && faceapi.tf ? faceapi.tf : null);
      if (isChromeOrAndroid && tfRef) {
        try {
          await tfRef.setBackend('cpu');
          await tfRef.ready();
          console.log('üîß Backend TensorFlow: CPU (Chrome/Android)');
        } catch (e) {
          console.warn('Backend CPU no disponible:', e);
        }
      }
      logToConsole('FACE MESH: cargando modelos...', false);
      try {
        await Promise.all([
          faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
          faceapi.loadFaceLandmarkModel(MODEL_URL)
        ]);
        faceMeshReady = true;
        logToConsole('FACE MESH: listo', false);
      } catch (err) {
        logToConsole('FACE MESH: error (abre F12 ‚Üí Console)', true);
        console.error('Face mesh error:', err);
      }
    }

    // Convierte landmarks de una detecci√≥n a coordenadas en p√≠xeles (para an√°lisis S√ç/NO)
    function getLandmarksInPixels(detection, w, h) {
      const positions = detection.landmarks.positions;
      const box = detection.detection?.box;
      const boxX = (box && typeof box.x === 'number') ? box.x : 0;
      const boxY = (box && typeof box.y === 'number') ? box.y : 0;
      const boxW = (box && typeof box.width === 'number') ? box.width : w;
      const boxH = (box && typeof box.height === 'number') ? box.height : h;
      const first = positions[0];
      const normalized = first && first.x <= 1 && first.y <= 1;
      const likelyBoxRelative = first && box && first.x >= 0 && first.x <= boxW && first.y >= 0 && first.y <= boxH;
      const out = [];
      for (let i = 0; i < positions.length; i++) {
        let x = positions[i].x;
        let y = positions[i].y;
        if (normalized) {
          x *= w;
          y *= h;
        } else if (likelyBoxRelative) {
          x += boxX;
          y += boxY;
        }
        out.push({ x, y });
      }
      return out;
    }

    function analyzeFacialResponse(landmarks, previousLandmarks) {
      let yesScore = 0;
      let noScore = 0;
      if (!landmarks || landmarks.length < 58) return 'NEUTRAL';

      const mouthLeft = landmarks[48];
      const mouthRight = landmarks[54];
      const noseTip = landmarks[30];
      if (mouthLeft && mouthRight && noseTip && mouthLeft.y < noseTip.y && mouthRight.y < noseTip.y) {
        yesScore += 2;
      }

      const leftEyebrow = landmarks[19];
      const rightEyebrow = landmarks[24];
      const leftEye = landmarks[37];
      if (leftEyebrow && leftEye) {
        const eyebrowDistance = leftEye.y - leftEyebrow.y;
        if (eyebrowDistance > 15) yesScore += 1;
      }
      if (rightEyebrow && landmarks[42]) {
        const eyebrowDistanceR = landmarks[42].y - rightEyebrow.y;
        if (eyebrowDistanceR > 15) yesScore += 1;
      }

      if (previousLandmarks && previousLandmarks.length >= 31) {
        const currentNose = landmarks[30];
        const prevNose = previousLandmarks[30];
        const verticalMove = Math.abs(currentNose.y - prevNose.y);
        if (verticalMove > 5) yesScore += 1;
        const horizontalMove = Math.abs(currentNose.x - prevNose.x);
        if (horizontalMove > 8) noScore += 1;
      }

      const mouthTop = landmarks[51];
      const mouthBottom = landmarks[57];
      if (mouthTop && mouthBottom) {
        const mouthHeight = mouthBottom.y - mouthTop.y;
        if (mouthHeight < 5) noScore += 1;
      }

      if (yesScore > noScore) return 'YES';
      if (noScore > yesScore) return 'NO';
      return 'NEUTRAL';
    }

    // Throttle para logs temporales (no saturar consola)
    let drawFaceMeshLogTick = 0;
    const DRAW_MESH_LOG_EVERY = 60;

    function drawFaceMeshCyan(ctx, results, width, height) {
      if (!results || results.length === 0) return;
      const w = width || ctx.canvas.width;
      const h = height || ctx.canvas.height;
      const radiusCyan = 3;
      const fillStyleCyan = 'rgba(0, 255, 255, 0.95)';
      results.forEach((detection) => {
        const positions = detection.landmarks.positions;
        const box = detection.detection?.box;
        const boxX = (box && typeof box.x === 'number') ? box.x : 0;
        const boxY = (box && typeof box.y === 'number') ? box.y : 0;
        const boxW = (box && typeof box.width === 'number') ? box.width : w;
        const boxH = (box && typeof box.height === 'number') ? box.height : h;
        const first = positions[0];
        const normalized = first && first.x <= 1 && first.y <= 1;
        const likelyBoxRelative = first && box && first.x >= 0 && first.x <= boxW && first.y >= 0 && first.y <= boxH;
        const firstThreeCoords = [];
        for (let i = 0; i < positions.length; i++) {
          let x = positions[i].x;
          let y = positions[i].y;
          if (normalized) {
            x *= w;
            y *= h;
          } else if (likelyBoxRelative) {
            x += boxX;
            y += boxY;
          }
          if (i < 3) firstThreeCoords.push({ x, y });
          if (i < 3 && drawFaceMeshLogTick++ % DRAW_MESH_LOG_EVERY === 0) {
            console.log(`[drawFaceMeshCyan] punto ${i} (x,y)=(${x.toFixed(1)}, ${y.toFixed(1)}) | fillStyle=${fillStyleCyan} radio=${radiusCyan}`);
          }
          ctx.shadowColor = '#0ff';
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.arc(x, y, radiusCyan, 0, Math.PI * 2);
          ctx.fillStyle = fillStyleCyan;
          ctx.fill();
          ctx.strokeStyle = '#0ff';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
        if (firstThreeCoords.length >= 3) {
          ctx.shadowBlur = 0;
          ctx.fillStyle = 'red';
          ctx.beginPath();
          ctx.arc(firstThreeCoords[0].x, firstThreeCoords[0].y, 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'yellow';
          ctx.beginPath();
          ctx.arc(firstThreeCoords[1].x, firstThreeCoords[1].y, 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'magenta';
          ctx.beginPath();
          ctx.arc(firstThreeCoords[2].x, firstThreeCoords[2].y, 20, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }

    // Funci√≥n helper para esperar video listo (debug)
    async function waitForVideoReady(videoEl) {
      return new Promise((resolve) => {
        const check = () => {
          if (videoEl.readyState >= 2 && videoEl.videoWidth > 0) {
            console.log('‚úÖ Video listo:', videoEl.videoWidth, 'x', videoEl.videoHeight);
            resolve();
          } else {
            console.log('‚è≥ Esperando video...', videoEl.readyState);
            setTimeout(check, 100);
          }
        };
        check();
      });
    }

    // Opciones del detector relajadas para mejor detecci√≥n
    const faceDetectorOptions = new faceapi.TinyFaceDetectorOptions({
      inputSize: 416,
      scoreThreshold: 0.2
    });

    // Canvas auxiliar: SOLO para detecci√≥n (face-api lee de aqu√≠). Video + malla se dibujan en el canvas VISIBLE (arregla Chrome/Android).
    let offscreenCanvas = null;
    let debugThrottle = 0;
    const debugEl = () => document.getElementById('debugOverlay');

    async function detectFaceMesh() {
      if (!faceMeshReady || video.readyState < 2) {
        requestAnimationFrame(detectFaceMesh);
        return;
      }
      const ctx = faceMeshCanvas.getContext('2d');
      if (!ctx) {
        requestAnimationFrame(detectFaceMesh);
        return;
      }
      const w = video.videoWidth;
      const h = video.videoHeight;
      faceMeshCanvas.width = w;
      faceMeshCanvas.height = h;

      if (!offscreenCanvas || offscreenCanvas.width !== w || offscreenCanvas.height !== h) {
        offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = w;
        offscreenCanvas.height = h;
      }
      const offCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
      offCtx.drawImage(video, 0, 0, w, h);

      const results = await faceapi.detectAllFaces(offscreenCanvas, faceDetectorOptions).withFaceLandmarks();

      if (results.length > 0) {
        ctx.drawImage(video, 0, 0, w, h);
        ctx.fillStyle = 'rgba(255, 0, 0, 0.85)';
        ctx.fillRect(Math.floor(w / 2) - 40, Math.floor(h / 2) - 40, 80, 80);
        drawFaceMeshCyan(ctx, results, w, h);

        const d = results[0];
        const landmarksPx = getLandmarksInPixels(d, w, h);
        const response = analyzeFacialResponse(landmarksPx, previousLandmarksPx);
        responseAccumulateFrames++;
        if (responseAccumulateFrames >= RESPONSE_ACCUMULATE_EVERY) {
          responseAccumulateFrames = 0;
          if (response === 'YES') responseCounts.yes++;
          if (response === 'NO') responseCounts.no++;
          if (response === 'NEUTRAL') responseCounts.neutral++;
        }
        previousLandmarksPx = landmarksPx;

        const liveEl = document.getElementById('live-response');
        if (liveEl) {
          if (response === 'YES') {
            liveEl.textContent = 'üëç Detectando S√ç';
            liveEl.style.color = '#00ff00';
          } else if (response === 'NO') {
            liveEl.textContent = 'üëé Detectando NO';
            liveEl.style.color = '#ff0000';
          } else {
            liveEl.textContent = 'üòê Neutral';
            liveEl.style.color = '#ffaa00';
          }
        }
        const btnResults = document.getElementById('btnVerResultados');
        if (btnResults) btnResults.style.display = 'block';

        if (debugThrottle++ % 30 === 0 && debugEl()) {
          const d = results[0];
          const pos = d.landmarks.positions;
          const first = pos[0];
          const box = d.detection?.box;
          const boxStr = box ? `box: ${Math.round(box.x)},${Math.round(box.y)} ${Math.round(box.width)}x${Math.round(box.height)}` : 'box: n/a';
          debugEl().innerHTML =
            `CANVAS: ${w}√ó${h}<br>` +
            `CARAS: ${results.length} | PTS: ${pos.length}<br>` +
            `first: (${first ? Math.round(first.x) : '?'}, ${first ? Math.round(first.y) : '?'})<br>` +
            boxStr + '<br>' +
            (first && first.x <= 1 ? '<span class="warn">coords normalizadas?</span>' : '') +
            (first && box && first.x >= 0 && first.x <= box.width && first.y >= 0 && first.y <= box.height ? '<br><span class="warn">usando offset box</span>' : '');
        }
      } else {
        ctx.drawImage(video, 0, 0, w, h);
        previousLandmarksPx = null;
        const liveEl = document.getElementById('live-response');
        if (liveEl) {
          liveEl.textContent = '';
        }
        if (debugThrottle++ % 30 === 0 && debugEl()) {
          debugEl().innerHTML = `CANVAS: ${w}√ó${h}<br>CARAS: 0<br><span class="err">Sin cara detectada</span>`;
        }
      }

      requestAnimationFrame(detectFaceMesh);
    }

    (async function init() {
      await startCamera();
      let detectionStarted = false;
      const startDetection = async () => {
        if (detectionStarted) return;
        detectionStarted = true;
        await initFaceMesh();
        await waitForVideoReady(video);
        video.style.visibility = 'hidden'; // Solo canvas (video+malla) visible; evita doble capa en Chrome/Android
        console.log('üé¨ Iniciando loop de detecci√≥n...');
        detectFaceMesh();
      };
      video.addEventListener('loadedmetadata', startDetection);
      if (video.readyState >= 2) {
        await startDetection();
      }
    })();

    // --- 2. L√ìGICA DE SIMULACI√ìN ---
    setInterval(() => {
      document.getElementById('valPitch').innerText = Math.floor(Math.random() * (160 - 100) + 100);
      const stressLevels = ["LOW", "MED", "HIGH"];
      document.getElementById('valStress').innerText = stressLevels[Math.floor(Math.random() * stressLevels.length)];
    }, 500);

    const fakeLogs = [
      "INITIALIZING BIO-SENSORS...",
      "AUDIO INPUT: DETECTED",
      "CALIBRATING FACE MESH...",
      "LOCKING TARGET...",
      "MICRO-TREMOR DETECTED (t=0.4s)",
      "PUPIL DILATION: IRREGULAR",
      "VOICE FREQUENCY: UNSTABLE",
      "CONFIDENCE INTERVAL: DROPPING",
      "CORRELATING DATA WITH CLOUD...",
      "GENERATING FINAL REPORT..."
    ];

    function startAnalysis() {
      const btn = document.getElementById('actionBtn');
      const scanLine = document.getElementById('scanLine');
      const consoleDiv = document.getElementById('consoleLog');
      const faceMesh = document.getElementById('faceMesh');

      btn.style.display = 'none';
      scanLine.style.display = 'block';

      faceMesh.style.transform = "translate(-50%, -50%) scale(1.1)";
      setInterval(() => {
        faceMesh.style.transform = faceMesh.style.transform === "translate(-50%, -50%) scale(1.1)"
          ? "translate(-50%, -50%) scale(1.0)"
          : "translate(-50%, -50%) scale(1.1)";
      }, 800);

      let delay = 0;
      fakeLogs.forEach((log, index) => {
        delay += (index < 3) ? 500 : 250;
        setTimeout(() => {
          const entry = document.createElement('div');
          entry.innerText = `> ${log}`;
          if(log.includes("UNSTABLE") || log.includes("DROPPING")) entry.style.color = "#ff3333";
          consoleDiv.prepend(entry);
        }, delay);
      });

      setTimeout(() => {
        showResult();
      }, delay + 1000);
    }

    function showResult() {
      const modal = document.getElementById('resultModal');
      const barVocal = document.getElementById('barVocal');
      const barFacial = document.getElementById('barFacial');
      barVocal.style.width = '0%';
      barFacial.style.width = '0%';
      modal.classList.add('active');
      requestAnimationFrame(() => {
        barVocal.style.width = '32%';
        barFacial.style.width = '41%';
      });
    }

    function resetDemo() {
      document.getElementById('resultModal').classList.remove('active');
      document.getElementById('barVocal').style.width = '0%';
      document.getElementById('barFacial').style.width = '0%';
      document.getElementById('actionBtn').style.display = 'block';
      document.getElementById('scanLine').style.display = 'none';
      document.getElementById('consoleLog').innerHTML = '<div>> SYSTEM READY</div><div>> WAITING FOR INPUT...</div>';
      document.getElementById('faceMesh').style.transform = 'translate(-50%, -50%)';
    }

    function showResults() {
      const total = responseCounts.yes + responseCounts.no;
      const cameraContainer = document.querySelector('.camera-container');
      if (!cameraContainer) return;
      document.getElementById('result-yes').style.display = 'none';
      document.getElementById('result-no').style.display = 'none';
      document.getElementById('result-tie').style.display = 'none';

      if (total === 0) {
        document.getElementById('live-response').textContent = 'Sin datos a√∫n';
        return;
      }
      cameraContainer.style.display = 'none';
      const yesPercent = (responseCounts.yes / total) * 100;
      const noPercent = (responseCounts.no / total) * 100;

      if (Math.abs(yesPercent - noPercent) < 5) {
        document.getElementById('result-tie').style.display = 'flex';
        document.querySelector('#result-tie .stat-item.yes .count').textContent = responseCounts.yes + ' S√ç';
        document.querySelector('#result-tie .stat-item.no .count').textContent = responseCounts.no + ' NO';
      } else if (yesPercent > noPercent) {
        document.getElementById('result-yes').style.display = 'flex';
        document.querySelector('#result-yes .big-number').textContent = Math.round(yesPercent) + '%';
        document.querySelector('#result-yes .stat-item.yes .count').textContent = responseCounts.yes + ' S√ç';
        document.querySelector('#result-yes .stat-item.no .count').textContent = responseCounts.no + ' NO';
      } else {
        document.getElementById('result-no').style.display = 'flex';
        document.querySelector('#result-no .big-number').textContent = Math.round(noPercent) + '%';
        document.querySelector('#result-no .stat-item.yes .count').textContent = responseCounts.yes + ' S√ç';
        document.querySelector('#result-no .stat-item.no .count').textContent = responseCounts.no + ' NO';
      }
    }

    function hideResultScreens() {
      document.getElementById('result-yes').style.display = 'none';
      document.getElementById('result-no').style.display = 'none';
      document.getElementById('result-tie').style.display = 'none';
      const cameraContainer = document.querySelector('.camera-container');
      if (cameraContainer) cameraContainer.style.display = '';
    }
  </script>
</body>
</html>
